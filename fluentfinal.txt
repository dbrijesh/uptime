-- Track state per log file
if not files_state then
    files_state = {}
end

-- Track which files we've seen and their run_ids
if not file_run_ids then
    file_run_ids = {}
end

function extract_run_id_from_log(tag, timestamp, record)
    if type(record) ~= "table" then
        return 1, timestamp, record
    end

    -- Extract filename from file_path
    local file_path = record["file_path"] or ""
    local filename = "unknown"
    
    if file_path ~= "" then
        filename = file_path:match("([^/]+)$") or "unknown"
    end
    
    -- Use worker_filename if available
    if record["worker_filename"] then
        filename = record["worker_filename"]
    end
    
    print("üîé [DEBUG] Processing file: " .. filename)

    -- Initialize state for this file if not exists
    if not files_state[filename] then
        files_state[filename] = {
            buffer = "",
            run_id = "unknown",
            found = false,
            expecting_value = false,
            line_count = 0
        }
        print("üîé [DEBUG] Initialized new state for: " .. filename)
    end

    local state = files_state[filename]
    state.line_count = state.line_count + 1

    -- If we already found run_id for this file, use it
    if state.found then
        record["run_id"] = state.run_id
        local new_tag = "github.runner." .. state.run_id
        print("üîé [DEBUG] Using existing run_id: " .. state.run_id .. " for file: " .. filename)
        return 2, new_tag, timestamp, record
    end

    -- Get log content
    local content = record["log"] or record["message"] or ""
    content = tostring(content):gsub("^%s+", ""):gsub("%s+$", "")

    -- Add to buffer for multiline processing
    state.buffer = state.buffer .. content .. "\n"

    print("üîé [DEBUG] Line " .. state.line_count .. " for " .. filename .. ": " .. content)

    -- Process the accumulated buffer for JSON patterns
    if state.expecting_value then
        -- Looking for value after finding "k": "run_id"
        local value_patterns = {
            '"v"%s*:%s*"([^"]+)"',
            '"v":%s*"([^"]+)"',
            '"v"%s*:%s*\'([^\']+)\'',
            '"v":%s*\'([^\']+)\''
        }
        
        for _, pattern in ipairs(value_patterns) do
            local run_id = content:match(pattern)
            if run_id then
                state.run_id = run_id
                state.found = true
                state.expecting_value = false
                record["run_id"] = run_id
                file_run_ids[filename] = run_id
                
                local new_tag = "github.runner." .. run_id
                print("‚úÖ [SUCCESS] Extracted run_id: " .. run_id .. " from file: " .. filename)
                
                -- Clear buffer to save memory
                state.buffer = ""
                return 2, new_tag, timestamp, record
            end
        end
        
        -- If we didn't find value after expecting it, reset
        state.expecting_value = false
        print("‚ö†Ô∏è [DEBUG] Expected value but didn't find it in: " .. filename)
        
    else
        -- Looking for "k": "run_id" pattern
        local key_patterns = {
            '"k"%s*:%s*"run_id"',
            '"k":%s*"run_id"',
            '"k"%s*:%s*\'run_id\'',
            '"k":%s*\'run_id\''
        }
        
        for _, pattern in ipairs(key_patterns) do
            if content:match(pattern) then
                state.expecting_value = true
                print("üìç [DEBUG] Found run_id key in " .. filename .. " - expecting value next")
                break
            end
        end
    end

    -- If buffer gets too large, clear it (memory management)
    if #state.buffer > 4096 then  -- 4KB limit
        state.buffer = ""
        print("‚ö†Ô∏è [DEBUG] Cleared buffer for: " .. filename)
    end

    -- Set run_id to unknown for now
    record["run_id"] = "unknown"
    return 1, timestamp, record
end

-- Optional: Clean up old file states periodically
function cleanup_old_files()
    -- Could be called periodically to prevent memory growth
end


[SERVICE]
    Flush         1
    Log_Level     info
    Daemon        off
    Parsers_File  /etc/fluent-bit/parsers.conf

# Define multiline parser for JSON
[PARSER]
    Name          multiline_json
    Format        regex
    Regex         ^\s*\{
    Skip_Empty_Lines On

[INPUT]
    Name              tail
    Path              /usr/bin/actions-runner/_diag/Worker_*.log
    Tag               github.runner
    Refresh_Interval  5
    Read_from_Head    false
    Skip_Long_Lines   off
    # CRITICAL: Enable multiline parsing
    Multiline         On
    Parser_Firstline  multiline_json
    # Capture the actual filename
    Path_Key          file_path

# Extract filename from path and add to record
[FILTER]
    Name                record_modifier
    Match               github.runner
    Record              worker_filename /usr/bin/actions-runner/_diag/(Worker_[^/]+)$

[FILTER]
    Name                lua
    Match               github.runner
    Script              /etc/fluent-bit/extract_run_id.lua
    Call                extract_run_id_from_log

[OUTPUT]
    Name                cloudwatch_logs
    Match               github.runner.*
    region              us-east-1
    log_group_name      githubrunnerlogs
    log_stream_name     runner-${run_id}-${HOSTNAME}
    auto_create_group   true
    auto_create_stream  true
    log_retention_days  7

# Fallback for records without run_id
[OUTPUT]
    Name                cloudwatch_logs
    Match               github.runner
    region              us-east-1
    log_group_name      githubrunnerlogs
    log_stream_name     runner-unknown-${HOSTNAME}
    auto_create_group   true
    auto_create_stream  true
    log_retention_days  7


















-- Track state per log file
if not files_state then
    files_state = {}
end

function extract_run_id_from_log(tag, ts, record)
    -- Always ensure record is a table
    if type(record) ~= "table" then
        print("‚ùå [DEBUG] Invalid record, got type:", type(record))
        return 1, ts, record
    end

    -- Scope state per file
    local fname = record["filename"] or "default"
    local state = files_state[fname] or { run_id = "unknown", found = false, expecting_value = false }
    files_state[fname] = state

    record["run_id"] = state.run_id

    print("üîé [DEBUG] Processing file:", fname)
    print("üîé [DEBUG] Current run_id state:", state.run_id, " found:", tostring(state.found), " expecting_value:", tostring(state.expecting_value))

    -- If already found, just retag
    if state.found then
        local new_tag = "github.runner." .. tostring(state.run_id)
        print("üîé [DEBUG] Already found run_id -> tagging record with:", new_tag)
        return 2, ts, record  -- Return 2 to indicate tag change, but don't return new_tag here
    end

    -- Extract current line
    local content = record["log"] or record["message"] or ""
    if type(content) ~= "string" then
        content = tostring(content)
    end
    local line = content:gsub("^%s+", ""):gsub("%s+$", ""):gsub(",$", "")

    print("üîé [DEBUG] Raw line from log:", line)

    if line == "" then
        print("‚ö†Ô∏è [DEBUG] Empty line, skipping")
        return 1, ts, record
    end

    -- If expecting value (after "k": "run_id")
    if state.expecting_value then
        print("üîé [DEBUG] Expecting run_id value in file:", fname)
        local value = line:match('"v"%s*:%s*"([^"]+)"')
                  or line:match('"v":%s*"([^"]+)"')
                  or line:match('"v"%s*:%s*\'([^\']+)\'')
                  or line:match('"v":%s*\'([^\']+)\'')
        if value then
            state.run_id = value
            state.found = true
            state.expecting_value = false
            record["run_id"] = value
            local new_tag = "github.runner." .. tostring(value)
            print("‚úÖ [DEBUG] Extracted run_id from", fname, "->", value)
            -- Change the tag for this record
            return 2, new_tag, ts, record
        else
            print("‚ö†Ô∏è [DEBUG] No value found after run_id key in file:", fname)
        end
        state.expecting_value = false
    else
        -- Look for "k": "run_id"
        if line:match('"k"%s*:%s*"run_id"')
        or line:match('"k":%s*"run_id"')
        or line:match('"k"%s*:%s*\'run_id\'')
        or line:match('"k":%s*\'run_id\'') then
            state.expecting_value = true
            print("üìç [DEBUG] Found run_id key in", fname, "- will extract value on next line")
        else
            print("üîé [DEBUG] No run_id key in this line for file:", fname)
        end
    end

    return 1, ts, record
end


[INPUT]
    Name              tail
    Path              /home/runner/_diag/Worker_*.log
    Tag               github.runner
    Refresh_Interval  5
    Read_from_Head    false
    Skip_Long_Lines   off
    Skip_Empty_Lines  on
    # Add these lines to capture filename
    Path_Key          filename
    # Optional: Use Tag_Regex to extract just the Worker name
    Tag_Regex         ^.*\/(Worker_[^\/]+)\.log$

# Add a filter to ensure filename is set properly
[FILTER]
    Name                record_modifier
    Match               github.runner
    Record              hostname ${HOSTNAME}
    # This will set filename from the Path_Key if not already set

[FILTER]
    Name    lua
    Match   github.runner
    Script  /etc/fluent-bit/extract_run_id.lua
    Call    extract_run_id_from_log










Track state per log file
if not files_state then
    files_state = {}
end

function extract_run_id_from_log(tag, ts, record)
    -- Always ensure record is a table
    if type(record) ~= "table" then
        print("‚ùå [DEBUG] Invalid record, got type:", type(record))
        return 1, ts, record
    end

    -- Scope state per file
    local fname = record["filename"] or "default"
    local state = files_state[fname] or { run_id = "unknown", found = false, expecting_value = false }
    files_state[fname] = state

    record["run_id"] = state.run_id

    print("üîé [DEBUG] Processing file:", fname)
    print("üîé [DEBUG] Current run_id state:", state.run_id, " found:", tostring(state.found), " expecting_value:", tostring(state.expecting_value))

    -- If already found, just retag
    if state.found then
        local new_tag = "github.runner." .. tostring(state.run_id)
        print("üîé [DEBUG] Already found run_id -> tagging record with:", new_tag)
        return 2, ts, record  -- Return 2 to indicate tag change, but don't return new_tag here
    end

    -- Extract current line
    local content = record["log"] or record["message"] or ""
    if type(content) ~= "string" then
        content = tostring(content)
    end
    local line = content:gsub("^%s+", ""):gsub("%s+$", ""):gsub(",$", "")

    print("üîé [DEBUG] Raw line from log:", line)

    if line == "" then
        print("‚ö†Ô∏è [DEBUG] Empty line, skipping")
        return 1, ts, record
    end

    -- If expecting value (after "k": "run_id")
    if state.expecting_value then
        print("üîé [DEBUG] Expecting run_id value in file:", fname)
        local value = line:match('"v"%s*:%s*"([^"]+)"')
                  or line:match('"v":%s*"([^"]+)"')
                  or line:match('"v"%s*:%s*\'([^\']+)\'')
                  or line:match('"v":%s*\'([^\']+)\'')
        if value then
            state.run_id = value
            state.found = true
            state.expecting_value = false
            record["run_id"] = value
            local new_tag = "github.runner." .. tostring(value)
            print("‚úÖ [DEBUG] Extracted run_id from", fname, "->", value)
            -- Change the tag for this record
            return 2, new_tag, ts, record
        else
            print("‚ö†Ô∏è [DEBUG] No value found after run_id key in file:", fname)
        end
        state.expecting_value = false
    else
        -- Look for "k": "run_id"
        if line:match('"k"%s*:%s*"run_id"')
        or line:match('"k":%s*"run_id"')
        or line:match('"k"%s*:%s*\'run_id\'')
        or line:match('"k":%s*\'run_id\'') then
            state.expecting_value = true
            print("üìç [DEBUG] Found run_id key in", fname, "- will extract value on next line")
        else
            print("üîé [DEBUG] No run_id key in this line for file:", fname)
        end
    end

    return 1, ts, record
end


-- Track state per log file
if not files_state then
    files_state = {}
end

function extract_run_id_from_log(tag, ts, record)
    -- Always ensure record is a table
    if type(record) ~= "table" then
        print("‚ùå [DEBUG] Invalid record, got type:", type(record))
        return -1, ts, {}
    end

    -- Scope state per file
    local fname = record["filename"] or "default"
    local state = files_state[fname] or { run_id = "unknown", found = false, expecting_value = false }
    files_state[fname] = state

    record["run_id"] = state.run_id

    print("üîé [DEBUG] Processing file:", fname)
    print("üîé [DEBUG] Current run_id state:", state.run_id, " found:", tostring(state.found), " expecting_value:", tostring(state.expecting_value))

    -- If already found, just retag
    if state.found then
        local new_tag = "github.runner." .. tostring(state.run_id)
        print("üîé [DEBUG] Already found run_id -> tagging record with:", new_tag)
        return 2, ts, new_tag, record
    end

    -- Extract current line
    local content = record["log"] or record["message"] or ""
    if type(content) ~= "string" then
        content = tostring(content)
    end
    local line = content:gsub("^%s+", ""):gsub("%s+$", ""):gsub(",$", "")

    print("üîé [DEBUG] Raw line from log:", line)

    if line == "" then
        print("‚ö†Ô∏è [DEBUG] Empty line, skipping")
        return 1, ts, record
    end

    -- If expecting value (after "k": "run_id")
    if state.expecting_value then
        print("üîé [DEBUG] Expecting run_id value in file:", fname)
        local value = line:match('"v"%s*:%s*"([^"]+)"')
                  or line:match('"v":%s*"([^"]+)"')
                  or line:match('"v"%s*:%s*\'([^\']+)\'')
                  or line:match('"v":%s*\'([^\']+)\'')
        if value then
            state.run_id = value
            state.found = true
            state.expecting_value = false
            record["run_id"] = value
            local new_tag = "github.runner." .. tostring(value)
            print("‚úÖ [DEBUG] Extracted run_id from", fname, "->", value)
            return 2, ts, new_tag, record
        else
            print("‚ö†Ô∏è [DEBUG] No value found after run_id key in file:", fname)
        end
        state.expecting_value = false
    else
        -- Look for "k": "run_id"
        if line:match('"k"%s*:%s*"run_id"')
        or line:match('"k":%s*"run_id"')
        or line:match('"k"%s*:%s*\'run_id\'')
        or line:match('"k":%s*\'run_id\'') then
            state.expecting_value = true
            print("üìç [DEBUG] Found run_id key in", fname, "- will extract value on next line")
        else
            print("üîé [DEBUG] No run_id key in this line for file:", fname)
        end
    end

    return 1, ts, record
end



-- Track state per log file
if not files_state then
    files_state = {}
end

function extract_run_id_from_log(tag, ts, record)
    if not record then
        record = {}
    end

    -- Get filename to scope state
    local fname = record["filename"] or "default"
    local state = files_state[fname] or { run_id = "unknown", found = false, expecting_value = false }
    files_state[fname] = state

    -- Always attach current run_id
    record["run_id"] = state.run_id

    -- Debug: incoming info
    print("üîé [DEBUG] Processing file:", fname)
    print("üîé [DEBUG] Current run_id state:", state.run_id, " found:", tostring(state.found), " expecting_value:", tostring(state.expecting_value))

    -- If already found, just retag
    if state.found then
        local new_tag = "github.runner." .. state.run_id
        print("üîé [DEBUG] Already found run_id -> tagging record with:", new_tag)
        return 2, ts, new_tag, record
    end

    -- Extract current line
    local content = record["log"] or record["message"] or ""
    if type(content) ~= "string" then
        content = tostring(content)
    end
    local line = content:gsub("^%s+", ""):gsub("%s+$", ""):gsub(",$", "")

    print("üîé [DEBUG] Raw line from log:", line)

    if line == "" then
        print("‚ö†Ô∏è [DEBUG] Empty line, skipping")
        return 1, ts, record
    end

    -- If expecting value (after "k": "run_id")
    if state.expecting_value then
        print("üîé [DEBUG] Expecting run_id value in file:", fname)
        local value = line:match('"v"%s*:%s*"([^"]+)"')
                  or line:match('"v":%s*"([^"]+)"')
                  or line:match('"v"%s*:%s*\'([^\']+)\'')
                  or line:match('"v":%s*\'([^\']+)\'')
        if value then
            state.run_id = value
            state.found = true
            state.expecting_value = false
            record["run_id"] = value
            local new_tag = "github.runner." .. value
            print("‚úÖ [DEBUG] Extracted run_id from", fname, "->", value)
            return 2, ts, new_tag, record
        else
            print("‚ö†Ô∏è [DEBUG] No value found after run_id key in file:", fname)
        end
        state.expecting_value = false
    else
        -- Look for "k": "run_id"
        if line:match('"k"%s*:%s*"run_id"')
        or line:match('"k":%s*"run_id"')
        or line:match('"k"%s*:%s*\'run_id\'')
        or line:match('"k":%s*\'run_id\'') then
            state.expecting_value = true
            print("üìç [DEBUG] Found run_id key in", fname, "- will extract value on next line")
        else
            print("üîé [DEBUG] No run_id key in this line for file:", fname)
        end
    end

    return 1, ts, record
end



[SERVICE]
    Flush         1
    Log_Level     info
    Daemon        off
    Parsers_File  /etc/fluent-bit/parsers.conf

[INPUT]
    Name              tail
    Path              /home/runner/_diag/Worker_*.log
    Tag               github.runner
    Path_Key          filename              # capture filename for per-file state
    Refresh_Interval  5
    Read_from_Head    false
    Skip_Long_Lines   off
    Skip_Empty_Lines  on

[FILTER]
    Name    lua
    Match   github.runner
    Script  /etc/fluent-bit/extract_run_id.lua
    Call    extract_run_id_from_log

# Debug filter to confirm run_id is set
[FILTER]
    Name    record_modifier
    Match   github.runner.*
    Record  debug_extraction true

[OUTPUT]
    Name                cloudwatch_logs
    Match               github.runner.*
    region              us-east-1
    log_group_name      /github-actions/runners
    log_stream_prefix   runner-
    auto_create_group   true
    auto_create_stream  true
    log_retention_days  7




-----------


-- State table for each log file
if not files_state then
    files_state = {}
end

function extract_run_id_from_log(tag, ts, record)
    -- Track state per log file
    local fname = record["filename"] or "default"
    local state = files_state[fname] or { run_id = "unknown", found = false, expecting_value = false }
    files_state[fname] = state

    -- Always attach current run_id to the record
    record["run_id"] = state.run_id

    -- If run_id already found for this file, just retag and return
    if state.found then
        local new_tag = "github.runner." .. state.run_id
        return 2, ts, new_tag, record
    end

    -- Clean up the log line
    local content = record["log"] or record["message"] or ""
    local line = content:gsub("^%s+", ""):gsub("%s+$", ""):gsub(",$", "")

    if not line or line == "" then
        return 1, ts, record
    end

    -- If we saw "k": "run_id" previously, expect value now
    if state.expecting_value then
        local value = line:match('"v"%s*:%s*"([^"]+)"')
                  or line:match('"v":%s*"([^"]+)"')
                  or line:match('"v"%s*:%s*\'([^\']+)\'')
                  or line:match('"v":%s*\'([^\']+)\'')
        if value then
            state.run_id = value
            state.found = true
            state.expecting_value = false
            record["run_id"] = value
            local new_tag = "github.runner." .. value
            print("‚úÖ Extracted run_id from " .. fname .. ": " .. value)
            return 2, ts, new_tag, record
        end
        state.expecting_value = false

    else
        -- Look for "k": "run_id"
        if line:match('"k"%s*:%s*"run_id"')
        or line:match('"k":%s*"run_id"')
        or line:match('"k"%s*:%s*\'run_id\'')
        or line:match('"k":%s*\'run_id\'') then
            state.expecting_value = true
            print("üìç Found run_id key in " .. fname .. ", waiting for value")
        end
    end

    return 1, ts, record
end
