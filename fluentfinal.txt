local file_states = {}

function extract_run_id_from_log(tag, timestamp, record)
    if type(record) ~= "table" then
        return 0, timestamp, record
    end

    local filename = "default"
    if record.file_path then
        filename = tostring(record.file_path):match("([^/]+)$") or "unknown"
    end

    if not file_states[filename] then
        file_states[filename] = {
            run_id = "unknown",
            found = false,
            expect_value = false
        }
    end

    local state = file_states[filename]

    if state.found then
        record.run_id = state.run_id
        return 2, timestamp, record
    end

    local content = record.log or ""
    content = tostring(content)

    if state.expect_value then
        -- Looking for v value with whitespace before "v"
        local run_id = content:match('%s*"v"%s*:%s*"([^"]+)"')
        if run_id then
            run_id = run_id:gsub("^%s+", ""):gsub("%s+$", "")
            state.run_id = run_id
            state.found = true
            record.run_id = run_id
            state.expect_value = false
            return 2, timestamp, record
        else
            state.expect_value = false
        end
    else
        -- Looking for k:run_id with whitespace BEFORE "k"
        if content:find('%s*"k"%s*:%s*"run_id"') then
            state.expect_value = true
        end
    end

    record.run_id = "unknown"
    return 2, timestamp, record
end










local file_states = {}

function extract_run_id_from_log(tag, timestamp, record)
    print("LUA START - Record type: " .. type(record))
    
    if type(record) ~= "table" then
        return 1, timestamp, record
    end

    local file_path = record["file_path"] or ""
    local filename = file_path:match("([^/]+)$") or "unknown"

    if not file_states[filename] then
        file_states[filename] = { run_id = "unknown", found = false, expect_value = false }
        print("Initialized state for: " .. filename)
    end

    local state = file_states[filename]
    print("State - run_id: " .. state.run_id .. ", found: " .. tostring(state.found) .. ", expect_value: " .. tostring(state.expect_value))

    -- Use cached run_id if found
    if state.found then
        record["run_id"] = state.run_id
        local new_tag = "github.runner." .. state.run_id
        print("RETURN: Using cached run_id -> " .. new_tag)
        return 2, new_tag, timestamp, record
    end

    local content = record["log"] or record["message"] or ""
    content = tostring(content)
    
    print("Processing content: '" .. content .. "'")

    -- Clean the content but preserve internal formatting
    local clean_content = content:gsub("^%s+", ""):gsub("%s+$", "")
    print("Cleaned content: '" .. clean_content .. "'")

    if state.expect_value then
        -- Looking for "v" value with tabs and spaces
        print("üîç Looking for v value...")
        
        -- More flexible patterns that handle tabs and spaces
        local patterns = {
            '^%s*"v"%s*:%s*"([^"]+)"',      -- "v" : "value" with any whitespace
            '^%s*"v":%s*"([^"]+)"',         -- "v":"value" with any whitespace before
            '"v"%s*:%s*"([^"]+)"',          -- "v" : "value" anywhere in line
            '"v":%s*"([^"]+)"'              -- "v":"value" anywhere in line
        }
        
        for i, pattern in ipairs(patterns) do
            local run_id = clean_content:match(pattern)
            if run_id then
                -- Clean the extracted run_id
                run_id = run_id:gsub("^%s+", ""):gsub("%s+$", ""):gsub(",$", "")
                state.run_id = run_id
                state.found = true
                record["run_id"] = run_id
                state.expect_value = false
                local new_tag = "github.runner." .. run_id
                print("‚úÖ SUCCESS: Extracted run_id: " .. run_id .. " (pattern " .. i .. ")")
                print("RETURN: 2, " .. new_tag .. ", timestamp, record")
                return 2, new_tag, timestamp, record
            end
        end
        
        print("‚ùå No v value found with any pattern")
        state.expect_value = false
        
    else
        -- Looking for "k": "run_id" with tabs and spaces
        print("üîç Looking for k:run_id...")
        
        local patterns = {
            '^%s*"k"%s*:%s*"run_id"',      -- "k" : "run_id" with any whitespace
            '^%s*"k":%s*"run_id"',         -- "k":"run_id" with any whitespace before
            '"k"%s*:%s*"run_id"',          -- "k" : "run_id" anywhere in line
            '"k":%s*"run_id"'              -- "k":"run_id" anywhere in line
        }
        
        for i, pattern in ipairs(patterns) do
            if clean_content:match(pattern) then
                state.expect_value = true
                print("üìç Found k:run_id (pattern " .. i .. ")")
                break
            end
        end
        
        if not state.expect_value then
            print("‚û°Ô∏è No k:run_id found")
        end
    end

    record["run_id"] = "unknown"
    print("RETURN: 1, timestamp, record (no change)")
    return 1, timestamp, record
end



-----------------


local file_states = {}

function extract_run_id_from_log(tag, timestamp, record)
    print("LUA START - Record type: " .. type(record))
    
    if type(record) ~= "table" then
        print("ERROR: Record not table")
        return 1, timestamp, record
    end

    local file_path = record["file_path"] or ""
    local filename = file_path:match("([^/]+)$") or "unknown"

    if not file_states[filename] then
        file_states[filename] = { run_id = "unknown", found = false, expect_value = false }
    end

    local state = file_states[filename]

    if state.found then
        record["run_id"] = state.run_id
        local new_tag = "github.runner." .. state.run_id
        print("RETURN: 2, " .. new_tag .. ", timestamp, record")
        return 2, new_tag, timestamp, record
    end

    local content = record["log"] or record["message"] or ""
    content = tostring(content)

    if state.expect_value then
        print("Looking for v in: " .. content)
        local run_id = content:match('%s*"v"%s*:%s*"([^"]+)"')
        if run_id then
            state.run_id = run_id
            state.found = true
            record["run_id"] = run_id
            state.expect_value = false
            local new_tag = "github.runner." .. run_id
            print("RETURN: 2, " .. new_tag .. ", timestamp, record")
            return 2, new_tag, timestamp, record
        end
        state.expect_value = false
    else
        if content:match('%s*"k"%s*:%s*"run_id"') then
            state.expect_value = true
            print("Found k:run_id in: " .. content)
        end
    end

    record["run_id"] = "unknown"
    print("RETURN: 1, timestamp, record")
    return 1, timestamp, record
end


-- Simple state tracking per file
local file_states = {}

function extract_run_id_from_log(tag, timestamp, record)
    if type(record) ~= "table" then
        return 1, timestamp, record
    end

    local file_path = record["file_path"] or ""
    local filename = file_path:match("([^/]+)$") or "unknown"

    if not file_states[filename] then
        file_states[filename] = { run_id = "unknown", found = false, expect_value = false }
    end

    local state = file_states[filename]

    -- Use cached run_id if found
    if state.found then
        record["run_id"] = state.run_id
        return 2, "github.runner." .. state.run_id, timestamp, record
    end

    local content = record["log"] or record["message"] or ""
    content = tostring(content)

    if state.expect_value then
        -- We previously found "k": "run_id", now look for the NEXT "v" value
        local run_id = content:match('%s*"v"%s*:%s*"([^"]+)"')
        if run_id then
            state.run_id = run_id
            state.found = true
            record["run_id"] = run_id
            state.expect_value = false
            return 2, "github.runner." .. run_id, timestamp, record
        end
        -- If we don't find "v" after "k": "run_id", reset
        state.expect_value = false
    else
        -- Only look for EXACTLY "k": "run_id" (not "ref" or others)
        if content:match('%s*"k"%s*:%s*"run_id"') then
            state.expect_value = true
        end
    end

    record["run_id"] = "unknown"
    return 1, timestamp, record
end


--------------
-- Simple state tracking per file
local file_states = {}

function extract_run_id_from_log(tag, timestamp, record)
    if type(record) ~= "table" then
        return 1, timestamp, record
    end

    local file_path = record["file_path"] or ""
    local filename = file_path:match("([^/]+)$") or "unknown"

    if not file_states[filename] then
        file_states[filename] = { 
            run_id = "unknown", 
            found = false, 
            expect_value = false 
        }
        print("üîé Initialized state for: " .. filename)
    end

    local state = file_states[filename]

    -- Use cached run_id if found
    if state.found then
        record["run_id"] = state.run_id
        local new_tag = "github.runner." .. state.run_id
        print("üîé Using cached run_id: " .. state.run_id)
        return 2, new_tag, timestamp, record
    end

    local content = record["log"] or record["message"] or ""
    content = tostring(content)

    print("üîé File: " .. filename .. " | State: " .. tostring(state.expect_value) .. " | Content: " .. content)

    if state.expect_value then
        -- Patterns for "v" with various spacing options
        local patterns_v = {
            '%s*"v"%s*:%s*"([^"]+)"',      -- spaces before "v", around colon
            '%s*"v":%s*"([^"]+)"',         -- spaces before "v", no spaces around colon
            '"v"%s*:%s*"([^"]+)"',         -- no spaces before "v", spaces around colon
            '"v":%s*"([^"]+)"'             -- no spaces anywhere
        }
        
        for _, pattern in ipairs(patterns_v) do
            local run_id = content:match(pattern)
            if run_id then
                state.run_id = run_id
                state.found = true
                record["run_id"] = run_id
                state.expect_value = false
                local new_tag = "github.runner." .. run_id
                print("‚úÖ Extracted run_id: " .. run_id)
                return 2, new_tag, timestamp, record
            end
        end
        state.expect_value = false
        print("‚ö†Ô∏è Expected value but didn't find pattern")
    else
        -- Patterns for "k" with various spacing options
        local patterns_k = {
            '%s*"k"%s*:%s*"run_id"',      -- spaces before "k", around colon
            '%s*"k":%s*"run_id"',         -- spaces before "k", no spaces around colon  
            '"k"%s*:%s*"run_id"',         -- no spaces before "k", spaces around colon
            '"k":%s*"run_id"'             -- no spaces anywhere
        }
        
        for _, pattern in ipairs(patterns_k) do
            if content:match(pattern) then
                state.expect_value = true
                print("üìç Found run_id key")
                break
            end
        end
    end

    record["run_id"] = "unknown"
    return 1, timestamp, record
end


---------



-- Simple state tracking per file
local file_states = {}

function extract_run_id_from_log(tag, timestamp, record)
    if type(record) ~= "table" then
        return 1, timestamp, record
    end

    -- Extract filename
    local file_path = record["file_path"] or ""
    local filename = file_path:match("([^/]+)$") or "unknown"

    -- Initialize state
    if not file_states[filename] then
        file_states[filename] = {
            run_id = "unknown",
            found = false,
            state = "searching"  -- "searching", "found_brace", "found_k", "expecting_v"
        }
        print("üîé [DEBUG] Initialized state for file: " .. filename)
    end

    local state = file_states[filename]

    -- Use cached run_id if found
    if state.found then
        record["run_id"] = state.run_id
        local new_tag = "github.runner." .. state.run_id
        print("üîé [DEBUG] Using cached run_id: " .. state.run_id)
        return 2, new_tag, timestamp, record
    end

    local content = record["log"] or record["message"] or ""
    content = tostring(content):gsub("^%s+", ""):gsub("%s+$", "")

    print("üîé [DEBUG] File: " .. filename .. " | State: " .. state.state .. " | Content: " .. content)

    -- State machine for multiline JSON parsing
    if state.state == "searching" then
        -- Looking for opening brace
        if content:match("^{%s*$") then
            state.state = "found_brace"
            print("üìç [DEBUG] Found opening brace")
        end
        
    elseif state.state == "found_brace" then
        -- Found opening brace, now look for "k": "run_id"
        if content:match('"k"%s*:%s*"run_id"') then
            state.state = "expecting_v"
            print("üìç [DEBUG] Found k: run_id line")
        else
            -- If we don't find the k line after brace, reset
            state.state = "searching"
        end
        
    elseif state.state == "expecting_v" then
        -- Found "k": "run_id", now look for "v" line
        local run_id = content:match('"v"%s*:%s*"([^"]+)"')
        if run_id then
            state.run_id = run_id
            state.found = true
            record["run_id"] = run_id
            state.state = "searching"
            local new_tag = "github.runner." .. run_id
            print("‚úÖ [SUCCESS] Extracted run_id: " .. run_id)
            return 2, new_tag, timestamp, record
        else
            -- If we don't find v line, reset
            state.state = "searching"
            print("‚ö†Ô∏è [DEBUG] Expected v value but didn't find it")
        end
    end

    record["run_id"] = "unknown"
    -- Return without tag change
    return 1, timestamp, record
end



-- Simple state tracking per file
local file_states = {}

function extract_run_id_from_log(tag, timestamp, record)
    if type(record) ~= "table" then
        return 1, timestamp, record
    end

    -- Extract filename
    local file_path = record["file_path"] or ""
    local filename = file_path:match("([^/]+)$") or "unknown"

    -- Initialize state
    if not file_states[filename] then
        file_states[filename] = {
            run_id = "unknown",
            found = false,
            state = "searching",  -- "searching", "found_k", "found_v"
            created_time = os.time()
        }
        print("üîé [DEBUG] Initialized state for file: " .. filename)
    end

    local state = file_states[filename]

    -- Use cached run_id if found
    if state.found then
        record["run_id"] = state.run_id
        local new_tag = "github.runner." .. state.run_id
        print("üîé [DEBUG] Using cached run_id: " .. state.run_id .. " for file: " .. filename)
        -- CORRECTED: Proper return order for tag change
        return 2, new_tag, timestamp, record
    end

    local content = record["log"] or record["message"] or ""
    content = tostring(content):gsub("^%s+", ""):gsub("%s+$", "")

    print("üîé [DEBUG] File: " .. filename .. " | State: " .. state.state .. " | Content: " .. content)

    -- State machine for multiline JSON parsing
    if state.state == "searching" then
        -- Looking for opening brace or "k" line
        if content:match("^{%s*$") or content:match('"k"%s*:%s*"run_id"') then
            state.state = "found_k"
            print("üìç [DEBUG] Found JSON start or k line in file: " .. filename)
        end
        
    elseif state.state == "found_k" then
        -- Previous line had opening brace, look for "k": "run_id" or directly for "v"
        if content:match('"k"%s*:%s*"run_id"') then
            state.state = "found_k_complete"
            print("üìç [DEBUG] Found k: run_id line in file: " .. filename)
        elseif content:match('"v"%s*:%s*"([^"]+)"') then
            local run_id = content:match('"v"%s*:%s*"([^"]+)"')
            state.run_id = run_id
            state.found = true
            record["run_id"] = run_id
            state.state = "searching"
            print("‚úÖ [SUCCESS] Extracted run_id: " .. run_id .. " from file: " .. filename)
            local new_tag = "github.runner." .. run_id
            -- CORRECTED: Proper return order for tag change
            return 2, new_tag, timestamp, record
        else
            -- Reset if we don't find what we expect
            state.state = "searching"
        end
        
    elseif state.state == "found_k_complete" then
        -- Found "k": "run_id", now look for "v" line
        local run_id = content:match('"v"%s*:%s*"([^"]+)"')
        if run_id then
            state.run_id = run_id
            state.found = true
            record["run_id"] = run_id
            state.state = "searching"
            print("‚úÖ [SUCCESS] Extracted run_id: " .. run_id .. " from file: " .. filename)
            local new_tag = "github.runner." .. run_id
            -- CORRECTED: Proper return order for tag change
            return 2, new_tag, timestamp, record
        end
        
        -- If we didn't find value, reset
        state.state = "searching"
        print("‚ö†Ô∏è [DEBUG] Expected v value but didn't find it in file: " .. filename)
    end

    record["run_id"] = "unknown"
    -- Return without tag change
    return 1, timestamp, record
end



[SERVICE]
    Flush         1
    Log_Level     info
    Daemon        off

[INPUT]
    Name              tail
    Path              /usr/bin/actions-runner/_diag/Worker_*.log
    Tag               github.runner
    Refresh_Interval  5
    Read_from_Head    false
    Skip_Long_Lines   off
    Path_Key          file_path

[FILTER]
    Name                lua
    Match               github.runner
    Script              /etc/fluent-bit/extract_run_id.lua
    Call                extract_run_id_from_log

# Output for records WITH run_id (tagged as github.runner.<run_id>)
[OUTPUT]
    Name                cloudwatch_logs
    Match               github.runner.*
    region              us-east-2
    log_group_name      githubrunnerlogs
    log_stream_name     runner-${run_id}-${HOSTNAME}
    auto_create_group   true
    log_retention_days  7

# Output for records WITHOUT run_id (keep original github.runner tag)
[OUTPUT]
    Name                cloudwatch_logs
    Match               github.runner
    region              us-east-2
    log_group_name      githubrunnerlogs
    log_stream_name     runner-unknown-${HOSTNAME}
    auto_create_group   true
    log_retention_days  7
















-- Simple state tracking per file
local file_states = {}

function extract_run_id_from_log(tag, timestamp, record)
    if type(record) ~= "table" then
        return 1, timestamp, record
    end

    -- Extract filename
    local file_path = record["file_path"] or ""
    local filename = file_path:match("([^/]+)$") or "unknown"

    -- Initialize state
    if not file_states[filename] then
        file_states[filename] = {
            run_id = "unknown",
            found = false,
            state = "searching",  -- "searching", "found_k", "found_v"
            created_time = os.time()
        }
    end

    local state = file_states[filename]

    -- Use cached run_id if found
    if state.found then
        record["run_id"] = state.run_id
        return 2, "github.runner." .. state.run_id, timestamp, record
    end

    local content = record["log"] or record["message"] or ""
    content = tostring(content):gsub("^%s+", ""):gsub("%s+$", "")

    print("üîé [DEBUG] File: " .. filename .. " | State: " .. state.state .. " | Content: " .. content)

    -- State machine for multiline JSON parsing
    if state.state == "searching" then
        -- Looking for opening brace or "k" line
        if content:match("^{%s*$") or content:match('"k"%s*:%s*"run_id"') then
            state.state = "found_k"
            print("üìç [DEBUG] Found JSON start or k line")
        end
        
    elseif state.state == "found_k" then
        -- Previous line had opening brace, look for "k": "run_id" or directly for "v"
        if content:match('"k"%s*:%s*"run_id"') then
            state.state = "found_k_complete"
            print("üìç [DEBUG] Found k: run_id line")
        elseif content:match('"v"%s*:%s*"([^"]+)"') then
            local run_id = content:match('"v"%s*:%s*"([^"]+)"')
            state.run_id = run_id
            state.found = true
            record["run_id"] = run_id
            state.state = "searching"
            print("‚úÖ [SUCCESS] Extracted run_id: " .. run_id)
            return 2, "github.runner." .. run_id, timestamp, record
        end
        
    elseif state.state == "found_k_complete" then
        -- Found "k": "run_id", now look for "v" line
        local run_id = content:match('"v"%s*:%s*"([^"]+)"')
        if run_id then
            state.run_id = run_id
            state.found = true
            record["run_id"] = run_id
            state.state = "searching"
            print("‚úÖ [SUCCESS] Extracted run_id: " .. run_id)
            return 2, "github.runner." .. run_id, timestamp, record
        end
        
        -- If we didn't find value, reset
        state.state = "searching"
    end

    record["run_id"] = "unknown"
    return 1, timestamp, record
end


[SERVICE]
    Flush         1
    Log_Level     info
    Daemon        off
    Parsers_File  /etc/fluent-bit/parsers.conf

[INPUT]
    Name              tail
    Path              /usr/bin/actions-runner/_diag/Worker_*.log
    Tag               github.runner
    Refresh_Interval  5
    Read_from_Head    false
    Skip_Long_Lines   off
    Path_Key          file_path

[FILTER]
    Name                record_modifier
    Match               github.runner
    Record              worker_filename ${file_path}

[FILTER]
    Name                lua
    Match               github.runner
    Script              /etc/fluent-bit/extract_run_id.lua
    Call                extract_run_id_from_log

[OUTPUT]
    Name                cloudwatch_logs
    Match               github.runner.*
    region              us-east-2
    log_group_name      githubrunnerlogs
    log_stream_name     runner-${run_id}-${HOSTNAME}
    auto_create_group   true
    auto_create_stream  true
    log_retention_days  7

# Fallback for records without run_id
[OUTPUT]
    Name                cloudwatch_logs
    Match               github.runner
    region              us-east-2
    log_group_name      githubrunnerlogs
    log_stream_name     runner-unknown-${HOSTNAME}
    auto_create_group   true
    auto_create_stream  true
    log_retention_days  7
















-- Track state per log file
if not files_state then
    files_state = {}
end

-- Track which files we've seen and their run_ids
if not file_run_ids then
    file_run_ids = {}
end

function extract_run_id_from_log(tag, timestamp, record)
    if type(record) ~= "table" then
        return 1, timestamp, record
    end

    -- Extract filename from file_path
    local file_path = record["file_path"] or ""
    local filename = "unknown"
    
    if file_path ~= "" then
        filename = file_path:match("([^/]+)$") or "unknown"
    end
    
    -- Use worker_filename if available
    if record["worker_filename"] then
        filename = record["worker_filename"]
    end
    
    print("üîé [DEBUG] Processing file: " .. filename)

    -- Initialize state for this file if not exists
    if not files_state[filename] then
        files_state[filename] = {
            buffer = "",
            run_id = "unknown",
            found = false,
            expecting_value = false,
            line_count = 0
        }
        print("üîé [DEBUG] Initialized new state for: " .. filename)
    end

    local state = files_state[filename]
    state.line_count = state.line_count + 1

    -- If we already found run_id for this file, use it
    if state.found then
        record["run_id"] = state.run_id
        local new_tag = "github.runner." .. state.run_id
        print("üîé [DEBUG] Using existing run_id: " .. state.run_id .. " for file: " .. filename)
        return 2, new_tag, timestamp, record
    end

    -- Get log content
    local content = record["log"] or record["message"] or ""
    content = tostring(content):gsub("^%s+", ""):gsub("%s+$", "")

    -- Add to buffer for multiline processing
    state.buffer = state.buffer .. content .. "\n"

    print("üîé [DEBUG] Line " .. state.line_count .. " for " .. filename .. ": " .. content)

    -- Process the accumulated buffer for JSON patterns
    if state.expecting_value then
        -- Looking for value after finding "k": "run_id"
        local value_patterns = {
            '"v"%s*:%s*"([^"]+)"',
            '"v":%s*"([^"]+)"',
            '"v"%s*:%s*\'([^\']+)\'',
            '"v":%s*\'([^\']+)\''
        }
        
        for _, pattern in ipairs(value_patterns) do
            local run_id = content:match(pattern)
            if run_id then
                state.run_id = run_id
                state.found = true
                state.expecting_value = false
                record["run_id"] = run_id
                file_run_ids[filename] = run_id
                
                local new_tag = "github.runner." .. run_id
                print("‚úÖ [SUCCESS] Extracted run_id: " .. run_id .. " from file: " .. filename)
                
                -- Clear buffer to save memory
                state.buffer = ""
                return 2, new_tag, timestamp, record
            end
        end
        
        -- If we didn't find value after expecting it, reset
        state.expecting_value = false
        print("‚ö†Ô∏è [DEBUG] Expected value but didn't find it in: " .. filename)
        
    else
        -- Looking for "k": "run_id" pattern
        local key_patterns = {
            '"k"%s*:%s*"run_id"',
            '"k":%s*"run_id"',
            '"k"%s*:%s*\'run_id\'',
            '"k":%s*\'run_id\''
        }
        
        for _, pattern in ipairs(key_patterns) do
            if content:match(pattern) then
                state.expecting_value = true
                print("üìç [DEBUG] Found run_id key in " .. filename .. " - expecting value next")
                break
            end
        end
    end

    -- If buffer gets too large, clear it (memory management)
    if #state.buffer > 4096 then  -- 4KB limit
        state.buffer = ""
        print("‚ö†Ô∏è [DEBUG] Cleared buffer for: " .. filename)
    end

    -- Set run_id to unknown for now
    record["run_id"] = "unknown"
    return 1, timestamp, record
end

-- Optional: Clean up old file states periodically
function cleanup_old_files()
    -- Could be called periodically to prevent memory growth
end


[SERVICE]
    Flush         1
    Log_Level     info
    Daemon        off
    Parsers_File  /etc/fluent-bit/parsers.conf

# Define multiline parser for JSON
[PARSER]
    Name          multiline_json
    Format        regex
    Regex         ^\s*\{
    Skip_Empty_Lines On

[INPUT]
    Name              tail
    Path              /usr/bin/actions-runner/_diag/Worker_*.log
    Tag               github.runner
    Refresh_Interval  5
    Read_from_Head    false
    Skip_Long_Lines   off
    # CRITICAL: Enable multiline parsing
    Multiline         On
    Parser_Firstline  multiline_json
    # Capture the actual filename
    Path_Key          file_path

# Extract filename from path and add to record
[FILTER]
    Name                record_modifier
    Match               github.runner
    Record              worker_filename /usr/bin/actions-runner/_diag/(Worker_[^/]+)$

[FILTER]
    Name                lua
    Match               github.runner
    Script              /etc/fluent-bit/extract_run_id.lua
    Call                extract_run_id_from_log

[OUTPUT]
    Name                cloudwatch_logs
    Match               github.runner.*
    region              us-east-1
    log_group_name      githubrunnerlogs
    log_stream_name     runner-${run_id}-${HOSTNAME}
    auto_create_group   true
    auto_create_stream  true
    log_retention_days  7

# Fallback for records without run_id
[OUTPUT]
    Name                cloudwatch_logs
    Match               github.runner
    region              us-east-1
    log_group_name      githubrunnerlogs
    log_stream_name     runner-unknown-${HOSTNAME}
    auto_create_group   true
    auto_create_stream  true
    log_retention_days  7


















-- Track state per log file
if not files_state then
    files_state = {}
end

function extract_run_id_from_log(tag, ts, record)
    -- Always ensure record is a table
    if type(record) ~= "table" then
        print("‚ùå [DEBUG] Invalid record, got type:", type(record))
        return 1, ts, record
    end

    -- Scope state per file
    local fname = record["filename"] or "default"
    local state = files_state[fname] or { run_id = "unknown", found = false, expecting_value = false }
    files_state[fname] = state

    record["run_id"] = state.run_id

    print("üîé [DEBUG] Processing file:", fname)
    print("üîé [DEBUG] Current run_id state:", state.run_id, " found:", tostring(state.found), " expecting_value:", tostring(state.expecting_value))

    -- If already found, just retag
    if state.found then
        local new_tag = "github.runner." .. tostring(state.run_id)
        print("üîé [DEBUG] Already found run_id -> tagging record with:", new_tag)
        return 2, ts, record  -- Return 2 to indicate tag change, but don't return new_tag here
    end

    -- Extract current line
    local content = record["log"] or record["message"] or ""
    if type(content) ~= "string" then
        content = tostring(content)
    end
    local line = content:gsub("^%s+", ""):gsub("%s+$", ""):gsub(",$", "")

    print("üîé [DEBUG] Raw line from log:", line)

    if line == "" then
        print("‚ö†Ô∏è [DEBUG] Empty line, skipping")
        return 1, ts, record
    end

    -- If expecting value (after "k": "run_id")
    if state.expecting_value then
        print("üîé [DEBUG] Expecting run_id value in file:", fname)
        local value = line:match('"v"%s*:%s*"([^"]+)"')
                  or line:match('"v":%s*"([^"]+)"')
                  or line:match('"v"%s*:%s*\'([^\']+)\'')
                  or line:match('"v":%s*\'([^\']+)\'')
        if value then
            state.run_id = value
            state.found = true
            state.expecting_value = false
            record["run_id"] = value
            local new_tag = "github.runner." .. tostring(value)
            print("‚úÖ [DEBUG] Extracted run_id from", fname, "->", value)
            -- Change the tag for this record
            return 2, new_tag, ts, record
        else
            print("‚ö†Ô∏è [DEBUG] No value found after run_id key in file:", fname)
        end
        state.expecting_value = false
    else
        -- Look for "k": "run_id"
        if line:match('"k"%s*:%s*"run_id"')
        or line:match('"k":%s*"run_id"')
        or line:match('"k"%s*:%s*\'run_id\'')
        or line:match('"k":%s*\'run_id\'') then
            state.expecting_value = true
            print("üìç [DEBUG] Found run_id key in", fname, "- will extract value on next line")
        else
            print("üîé [DEBUG] No run_id key in this line for file:", fname)
        end
    end

    return 1, ts, record
end


[INPUT]
    Name              tail
    Path              /home/runner/_diag/Worker_*.log
    Tag               github.runner
    Refresh_Interval  5
    Read_from_Head    false
    Skip_Long_Lines   off
    Skip_Empty_Lines  on
    # Add these lines to capture filename
    Path_Key          filename
    # Optional: Use Tag_Regex to extract just the Worker name
    Tag_Regex         ^.*\/(Worker_[^\/]+)\.log$

# Add a filter to ensure filename is set properly
[FILTER]
    Name                record_modifier
    Match               github.runner
    Record              hostname ${HOSTNAME}
    # This will set filename from the Path_Key if not already set

[FILTER]
    Name    lua
    Match   github.runner
    Script  /etc/fluent-bit/extract_run_id.lua
    Call    extract_run_id_from_log










Track state per log file
if not files_state then
    files_state = {}
end

function extract_run_id_from_log(tag, ts, record)
    -- Always ensure record is a table
    if type(record) ~= "table" then
        print("‚ùå [DEBUG] Invalid record, got type:", type(record))
        return 1, ts, record
    end

    -- Scope state per file
    local fname = record["filename"] or "default"
    local state = files_state[fname] or { run_id = "unknown", found = false, expecting_value = false }
    files_state[fname] = state

    record["run_id"] = state.run_id

    print("üîé [DEBUG] Processing file:", fname)
    print("üîé [DEBUG] Current run_id state:", state.run_id, " found:", tostring(state.found), " expecting_value:", tostring(state.expecting_value))

    -- If already found, just retag
    if state.found then
        local new_tag = "github.runner." .. tostring(state.run_id)
        print("üîé [DEBUG] Already found run_id -> tagging record with:", new_tag)
        return 2, ts, record  -- Return 2 to indicate tag change, but don't return new_tag here
    end

    -- Extract current line
    local content = record["log"] or record["message"] or ""
    if type(content) ~= "string" then
        content = tostring(content)
    end
    local line = content:gsub("^%s+", ""):gsub("%s+$", ""):gsub(",$", "")

    print("üîé [DEBUG] Raw line from log:", line)

    if line == "" then
        print("‚ö†Ô∏è [DEBUG] Empty line, skipping")
        return 1, ts, record
    end

    -- If expecting value (after "k": "run_id")
    if state.expecting_value then
        print("üîé [DEBUG] Expecting run_id value in file:", fname)
        local value = line:match('"v"%s*:%s*"([^"]+)"')
                  or line:match('"v":%s*"([^"]+)"')
                  or line:match('"v"%s*:%s*\'([^\']+)\'')
                  or line:match('"v":%s*\'([^\']+)\'')
        if value then
            state.run_id = value
            state.found = true
            state.expecting_value = false
            record["run_id"] = value
            local new_tag = "github.runner." .. tostring(value)
            print("‚úÖ [DEBUG] Extracted run_id from", fname, "->", value)
            -- Change the tag for this record
            return 2, new_tag, ts, record
        else
            print("‚ö†Ô∏è [DEBUG] No value found after run_id key in file:", fname)
        end
        state.expecting_value = false
    else
        -- Look for "k": "run_id"
        if line:match('"k"%s*:%s*"run_id"')
        or line:match('"k":%s*"run_id"')
        or line:match('"k"%s*:%s*\'run_id\'')
        or line:match('"k":%s*\'run_id\'') then
            state.expecting_value = true
            print("üìç [DEBUG] Found run_id key in", fname, "- will extract value on next line")
        else
            print("üîé [DEBUG] No run_id key in this line for file:", fname)
        end
    end

    return 1, ts, record
end


-- Track state per log file
if not files_state then
    files_state = {}
end

function extract_run_id_from_log(tag, ts, record)
    -- Always ensure record is a table
    if type(record) ~= "table" then
        print("‚ùå [DEBUG] Invalid record, got type:", type(record))
        return -1, ts, {}
    end

    -- Scope state per file
    local fname = record["filename"] or "default"
    local state = files_state[fname] or { run_id = "unknown", found = false, expecting_value = false }
    files_state[fname] = state

    record["run_id"] = state.run_id

    print("üîé [DEBUG] Processing file:", fname)
    print("üîé [DEBUG] Current run_id state:", state.run_id, " found:", tostring(state.found), " expecting_value:", tostring(state.expecting_value))

    -- If already found, just retag
    if state.found then
        local new_tag = "github.runner." .. tostring(state.run_id)
        print("üîé [DEBUG] Already found run_id -> tagging record with:", new_tag)
        return 2, ts, new_tag, record
    end

    -- Extract current line
    local content = record["log"] or record["message"] or ""
    if type(content) ~= "string" then
        content = tostring(content)
    end
    local line = content:gsub("^%s+", ""):gsub("%s+$", ""):gsub(",$", "")

    print("üîé [DEBUG] Raw line from log:", line)

    if line == "" then
        print("‚ö†Ô∏è [DEBUG] Empty line, skipping")
        return 1, ts, record
    end

    -- If expecting value (after "k": "run_id")
    if state.expecting_value then
        print("üîé [DEBUG] Expecting run_id value in file:", fname)
        local value = line:match('"v"%s*:%s*"([^"]+)"')
                  or line:match('"v":%s*"([^"]+)"')
                  or line:match('"v"%s*:%s*\'([^\']+)\'')
                  or line:match('"v":%s*\'([^\']+)\'')
        if value then
            state.run_id = value
            state.found = true
            state.expecting_value = false
            record["run_id"] = value
            local new_tag = "github.runner." .. tostring(value)
            print("‚úÖ [DEBUG] Extracted run_id from", fname, "->", value)
            return 2, ts, new_tag, record
        else
            print("‚ö†Ô∏è [DEBUG] No value found after run_id key in file:", fname)
        end
        state.expecting_value = false
    else
        -- Look for "k": "run_id"
        if line:match('"k"%s*:%s*"run_id"')
        or line:match('"k":%s*"run_id"')
        or line:match('"k"%s*:%s*\'run_id\'')
        or line:match('"k":%s*\'run_id\'') then
            state.expecting_value = true
            print("üìç [DEBUG] Found run_id key in", fname, "- will extract value on next line")
        else
            print("üîé [DEBUG] No run_id key in this line for file:", fname)
        end
    end

    return 1, ts, record
end



-- Track state per log file
if not files_state then
    files_state = {}
end

function extract_run_id_from_log(tag, ts, record)
    if not record then
        record = {}
    end

    -- Get filename to scope state
    local fname = record["filename"] or "default"
    local state = files_state[fname] or { run_id = "unknown", found = false, expecting_value = false }
    files_state[fname] = state

    -- Always attach current run_id
    record["run_id"] = state.run_id

    -- Debug: incoming info
    print("üîé [DEBUG] Processing file:", fname)
    print("üîé [DEBUG] Current run_id state:", state.run_id, " found:", tostring(state.found), " expecting_value:", tostring(state.expecting_value))

    -- If already found, just retag
    if state.found then
        local new_tag = "github.runner." .. state.run_id
        print("üîé [DEBUG] Already found run_id -> tagging record with:", new_tag)
        return 2, ts, new_tag, record
    end

    -- Extract current line
    local content = record["log"] or record["message"] or ""
    if type(content) ~= "string" then
        content = tostring(content)
    end
    local line = content:gsub("^%s+", ""):gsub("%s+$", ""):gsub(",$", "")

    print("üîé [DEBUG] Raw line from log:", line)

    if line == "" then
        print("‚ö†Ô∏è [DEBUG] Empty line, skipping")
        return 1, ts, record
    end

    -- If expecting value (after "k": "run_id")
    if state.expecting_value then
        print("üîé [DEBUG] Expecting run_id value in file:", fname)
        local value = line:match('"v"%s*:%s*"([^"]+)"')
                  or line:match('"v":%s*"([^"]+)"')
                  or line:match('"v"%s*:%s*\'([^\']+)\'')
                  or line:match('"v":%s*\'([^\']+)\'')
        if value then
            state.run_id = value
            state.found = true
            state.expecting_value = false
            record["run_id"] = value
            local new_tag = "github.runner." .. value
            print("‚úÖ [DEBUG] Extracted run_id from", fname, "->", value)
            return 2, ts, new_tag, record
        else
            print("‚ö†Ô∏è [DEBUG] No value found after run_id key in file:", fname)
        end
        state.expecting_value = false
    else
        -- Look for "k": "run_id"
        if line:match('"k"%s*:%s*"run_id"')
        or line:match('"k":%s*"run_id"')
        or line:match('"k"%s*:%s*\'run_id\'')
        or line:match('"k":%s*\'run_id\'') then
            state.expecting_value = true
            print("üìç [DEBUG] Found run_id key in", fname, "- will extract value on next line")
        else
            print("üîé [DEBUG] No run_id key in this line for file:", fname)
        end
    end

    return 1, ts, record
end



[SERVICE]
    Flush         1
    Log_Level     info
    Daemon        off
    Parsers_File  /etc/fluent-bit/parsers.conf

[INPUT]
    Name              tail
    Path              /home/runner/_diag/Worker_*.log
    Tag               github.runner
    Path_Key          filename              # capture filename for per-file state
    Refresh_Interval  5
    Read_from_Head    false
    Skip_Long_Lines   off
    Skip_Empty_Lines  on

[FILTER]
    Name    lua
    Match   github.runner
    Script  /etc/fluent-bit/extract_run_id.lua
    Call    extract_run_id_from_log

# Debug filter to confirm run_id is set
[FILTER]
    Name    record_modifier
    Match   github.runner.*
    Record  debug_extraction true

[OUTPUT]
    Name                cloudwatch_logs
    Match               github.runner.*
    region              us-east-1
    log_group_name      /github-actions/runners
    log_stream_prefix   runner-
    auto_create_group   true
    auto_create_stream  true
    log_retention_days  7




-----------


-- State table for each log file
if not files_state then
    files_state = {}
end

function extract_run_id_from_log(tag, ts, record)
    -- Track state per log file
    local fname = record["filename"] or "default"
    local state = files_state[fname] or { run_id = "unknown", found = false, expecting_value = false }
    files_state[fname] = state

    -- Always attach current run_id to the record
    record["run_id"] = state.run_id

    -- If run_id already found for this file, just retag and return
    if state.found then
        local new_tag = "github.runner." .. state.run_id
        return 2, ts, new_tag, record
    end

    -- Clean up the log line
    local content = record["log"] or record["message"] or ""
    local line = content:gsub("^%s+", ""):gsub("%s+$", ""):gsub(",$", "")

    if not line or line == "" then
        return 1, ts, record
    end

    -- If we saw "k": "run_id" previously, expect value now
    if state.expecting_value then
        local value = line:match('"v"%s*:%s*"([^"]+)"')
                  or line:match('"v":%s*"([^"]+)"')
                  or line:match('"v"%s*:%s*\'([^\']+)\'')
                  or line:match('"v":%s*\'([^\']+)\'')
        if value then
            state.run_id = value
            state.found = true
            state.expecting_value = false
            record["run_id"] = value
            local new_tag = "github.runner." .. value
            print("‚úÖ Extracted run_id from " .. fname .. ": " .. value)
            return 2, ts, new_tag, record
        end
        state.expecting_value = false

    else
        -- Look for "k": "run_id"
        if line:match('"k"%s*:%s*"run_id"')
        or line:match('"k":%s*"run_id"')
        or line:match('"k"%s*:%s*\'run_id\'')
        or line:match('"k":%s*\'run_id\'') then
            state.expecting_value = true
            print("üìç Found run_id key in " .. fname .. ", waiting for value")
        end
    end

    return 1, ts, record
end
