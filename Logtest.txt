

import boto3
import json
from datetime import datetime, timezone
import os

logs = boto3.client('logs')

# Preconfigured log group (secure)
LOG_GROUP_NAME = os.environ.get("LOG_GROUP_NAME", "/aws/codebuild/github-runner-logs")

def lambda_handler(event, context):
    try:
        params = event.get("queryStringParameters") or {}

        # Extract user-provided filters
        run_id = params.get("run_id")
        repo_name = params.get("repo_name")
        job_name = params.get("job_name")
        from_time = params.get("from")
        to_time = params.get("to")

        # Convert timestamps to milliseconds
        start_time = None
        end_time = None
        if from_time:
            start_time = int(datetime.fromisoformat(from_time.replace('Z', '+00:00')).timestamp() * 1000)
        if to_time:
            end_time = int(datetime.fromisoformat(to_time.replace('Z', '+00:00')).timestamp() * 1000)

        # Build stream name filter
        filters = [f for f in [run_id, repo_name, job_name] if f]

        # Fetch matching log streams
        matching_streams = []
        paginator = logs.get_paginator("describe_log_streams")
        for page in paginator.paginate(logGroupName=LOG_GROUP_NAME):
            for stream in page.get("logStreams", []):
                name = stream["logStreamName"]
                if all(f in name for f in filters):
                    matching_streams.append(name)

        if not matching_streams:
            return {
                "statusCode": 200,
                "headers": {"Access-Control-Allow-Origin": "*"},
                "body": json.dumps({"logStreams": []})
            }

        # Fetch log events for each matching stream
        result = {"logStreams": []}
        for stream_name in matching_streams:
            kwargs = {
                "logGroupName": LOG_GROUP_NAME,
                "logStreamName": stream_name,
                "startFromHead": True
            }

            if start_time:
                kwargs["startTime"] = start_time
            if end_time:
                kwargs["endTime"] = end_time

            response = logs.get_log_events(**kwargs)
            events = [
                {
                    "timestamp": datetime.fromtimestamp(e["timestamp"] / 1000, tz=timezone.utc).isoformat(),
                    "message": e["message"]
                } for e in response.get("events", [])
            ]

            result["logStreams"].append({
                "name": stream_name,
                "events": events
            })

        return {
            "statusCode": 200,
            "headers": {
                "Access-Control-Allow-Origin": "*",
                "Content-Type": "application/json"
            },
            "body": json.dumps(result)
        }

    except Exception as e:
        print("Error:", str(e))
        return {
            "statusCode": 500,
            "headers": {"Access-Control-Allow-Origin": "*"},
            "body": json.dumps({"error": str(e)})
        }











import json
import boto3
import time

logs = boto3.client('logs')

def lambda_handler(event, context):
    try:
        params = event.get('queryStringParameters') or {}
        log_group = params.get('logGroupName')
        query = params.get('query', '')
        start_time = int(time.time()) - 3600  # Default: last 1 hour
        end_time = int(time.time())

        if 'start' in params:
            start_time = int(params['start'])
        if 'end' in params:
            end_time = int(params['end'])

        if not log_group:
            return {
                'statusCode': 400,
                'body': json.dumps({'error': 'Missing logGroupName'})
            }

        # Run Logs Insights query
        query_string = f'fields @timestamp, @message | sort @timestamp desc | filter @message like /{query}/'
        response = logs.start_query(
            logGroupName=log_group,
            startTime=start_time,
            endTime=end_time,
            queryString=query_string,
            limit=50
        )

        query_id = response['queryId']

        # Wait for results
        time.sleep(2)
        result = logs.get_query_results(queryId=query_id)

        # Format results
        logs_list = []
        for r in result['results']:
            entry = {f['field']: f['value'] for f in r if f['field'] in ['@timestamp', '@message']}
            logs_list.append(entry)

        return {
            'statusCode': 200,
            'headers': {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*'
            },
            'body': json.dumps(logs_list)
        }

    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'error': str(e)})
        }





{
  "Effect": "Allow",
  "Action": [
    "logs:StartQuery",
    "logs:GetQueryResults",
    "logs:DescribeLogGroups",
    "logs:DescribeLogStreams"
  ],
  "Resource": "*"
}


<!DOCTYPE html>
<html>
<head>
  <title>CloudWatch Log Viewer</title>
  <style>
    body { font-family: Arial; padding: 20px; background: #f9fafb; }
    input, select, button { padding: 8px; margin: 5px; }
    pre { background: #111; color: #0f0; padding: 10px; border-radius: 8px; }
  </style>
</head>
<body>
  <h2>CloudWatch Log Viewer</h2>
  <label>Log Group:</label>
  <input type="text" id="logGroup" placeholder="/aws/lambda/my-function">
  <label>Search:</label>
  <input type="text" id="query" placeholder="error or keyword">
  <button onclick="fetchLogs()">Fetch Logs</button>
  <div id="result"></div>

  <script>
    const apiUrl = "https://abc123.execute-api.us-east-1.amazonaws.com/logs";

    async function fetchLogs() {
      const logGroup = document.getElementById('logGroup').value;
      const query = document.getElementById('query').value;
      const url = `${apiUrl}?logGroupName=${encodeURIComponent(logGroup)}&query=${encodeURIComponent(query)}`;

      document.getElementById('result').innerHTML = '<p>Loading...</p>';

      try {
        const res = await fetch(url);
        const data = await res.json();
        if (data.error) throw new Error(data.error);
        const logsHtml = data.map(d => `<pre>[${d['@timestamp']}] ${d['@message']}</pre>`).join('');
        document.getElementById('result').innerHTML = logsHtml || '<p>No logs found.</p>';
      } catch (err) {
        document.getElementById('result').innerHTML = `<p style="color:red;">Error: ${err.message}</p>`;
      }
    }
  </script>
</body>
</html>
