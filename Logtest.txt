<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>CloudWatch Log Tester</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Inter, Roboto, Arial, sans-serif; margin: 20px; background:#f5f7fb; color:#111 }
    .card { background:#fff; padding:16px; border-radius:10px; box-shadow:0 6px 18px rgba(0,0,0,0.06); max-width:980px; margin:0 auto }
    h1{ margin:0 0 12px; font-size:20px }
    label{ display:block; margin-top:8px; font-size:13px; color:#333 }
    input[type="text"], input[type="datetime-local"] { width:100%; padding:8px 10px; margin-top:6px; border:1px solid #d7dce6; border-radius:6px; font-size:14px; background:#fff }
    .grid { display:grid; grid-template-columns:repeat(3,1fr); gap:12px; align-items:end; }
    .row { display:flex; gap:8px; margin-top:12px }
    button { background:#0b6b3a; color:#fff; padding:10px 14px; border:none; border-radius:8px; cursor:pointer }
    button:disabled { opacity:0.6; cursor:not-allowed }
    pre { background:#0b1220; color:#9be6a6; padding:10px; border-radius:8px; overflow:auto; max-height:380px; font-family: Menlo, Monaco, monospace; font-size:13px; line-height:1.35 }
    .stream { margin-top:12px; border:1px solid #e6eef1; padding:10px; border-radius:8px; background:#fbfeff }
    .stream h3 { margin:0 0 8px; font-size:14px; color:#0b3550 }
    .event { border-top:1px dashed #e7eef1; padding:8px 0; font-family: monospace; white-space:pre-wrap; color:#111 }
    .meta { color:#6c757d; font-size:12px }
    .small { font-size:13px; color:#444 }
    .error { color:#b91c1c; margin-top:12px }
    @media (max-width:720px){ .grid{ grid-template-columns:1fr } }
  </style>
</head>
<body>
  <div class="card">
    <h1>CloudWatch Log Viewer — Simple Tester</h1>
    <div class="small">Uses your API Gateway endpoint. Provide any combination of <code>run_id</code>, <code>repo_name</code>, <code>job_name</code> and an optional <em>from / to</em> timestamp range.</div>

    <div style="margin-top:12px">
      <label>API Endpoint (replace with your API Gateway URL)</label>
      <input id="apiUrl" type="text" placeholder="https://<api-id>.execute-api.<region>.amazonaws.com/prod/logs" value="" />
    </div>

    <div class="grid" style="margin-top:12px">
      <div>
        <label>run_id</label>
        <input id="runId" type="text" placeholder="e.g. 10001" />
      </div>
      <div>
        <label>repo_name</label>
        <input id="repoName" type="text" placeholder="e.g. my-repo" />
      </div>
      <div>
        <label>job_name</label>
        <input id="jobName" type="text" placeholder="e.g. build or test" />
      </div>
    </div>

    <div class="grid" style="margin-top:12px">
      <div>
        <label>From (UTC)</label>
        <input id="fromTime" type="datetime-local" />
      </div>
      <div>
        <label>To (UTC)</label>
        <input id="toTime" type="datetime-local" />
      </div>
      <div style="display:flex; align-items:flex-end; gap:8px">
        <button id="fetchBtn">Fetch Logs</button>
        <button id="clearBtn" style="background:#6b7280">Clear</button>
      </div>
    </div>

    <div class="row" style="margin-top:12px">
      <div class="small">Note: timestamps should be in UTC. Example ISO string generated by browser when submitted.</div>
    </div>

    <div id="status" class="small" style="margin-top:10px"></div>
    <div id="error" class="error"></div>

    <div id="result" style="margin-top:14px"></div>

  </div>

<script>
  // Helper: convert datetime-local value to ISO Z string (UTC)
  function toISOZ(dtLocal) {
    if (!dtLocal) return null;
    // dtLocal like "2025-10-09T08:00"
    const d = new Date(dtLocal);
    if (isNaN(d.getTime())) return null;
    return d.toISOString(); // returns with Z
  }

  function showStatus(msg) {
    document.getElementById('status').textContent = msg || '';
  }
  function showError(msg) {
    document.getElementById('error').textContent = msg || '';
  }

  function clearResults() {
    document.getElementById('result').innerHTML = '';
    showStatus('');
    showError('');
  }

  async function fetchLogs() {
    clearResults();
    const apiUrl = document.getElementById('apiUrl').value.trim();
    if (!apiUrl) {
      showError('Please provide the API URL.');
      return;
    }

    const params = new URLSearchParams();
    const runId = document.getElementById('runId').value.trim();
    const repoName = document.getElementById('repoName').value.trim();
    const jobName = document.getElementById('jobName').value.trim();
    const fromTime = toISOZ(document.getElementById('fromTime').value);
    const toTime = toISOZ(document.getElementById('toTime').value);

    if (runId) params.append('run_id', runId);
    if (repoName) params.append('repo_name', repoName);
    if (jobName) params.append('job_name', jobName);
    if (fromTime) params.append('from', fromTime);
    if (toTime) params.append('to', toTime);

    const url = apiUrl + (params.toString() ? ('?' + params.toString()) : '');
    showStatus('Fetching from: ' + url);

    const btn = document.getElementById('fetchBtn');
    btn.disabled = true;

    try {
      const resp = await fetch(url, { method: 'GET' });
      if (!resp.ok) {
        const text = await resp.text();
        showError('HTTP ' + resp.status + ': ' + text);
        btn.disabled = false;
        showStatus('');
        return;
      }
      const json = await resp.json();
      renderResult(json);
      showStatus('Fetched OK — streams: ' + (json.logStreams ? json.logStreams.length : 0));
    } catch (e) {
      showError('Fetch error: ' + e.message);
    } finally {
      btn.disabled = false;
    }
  }

  function renderResult(obj) {
    const container = document.getElementById('result');
    container.innerHTML = '';

    if (!obj || !Array.isArray(obj.logStreams) || obj.logStreams.length === 0) {
      container.innerHTML = '<div class="small" style="margin-top:10px">No matching log streams / events found.</div>';
      return;
    }

    // Render each log stream
    obj.logStreams.forEach(ls => {
      const div = document.createElement('div');
      div.className = 'stream';

      const h = document.createElement('h3');
      h.textContent = ls.name || '(unknown stream)';
      div.appendChild(h);

      const meta = document.createElement('div');
      meta.className = 'meta';
      const count = (Array.isArray(ls.events) ? ls.events.length : 0);
      meta.textContent = `Events: ${count}`;
      div.appendChild(meta);

      if (!Array.isArray(ls.events) || ls.events.length === 0) {
        const eempty = document.createElement('div');
        eempty.className = 'small';
        eempty.textContent = 'No events for this stream in the requested time window.';
        div.appendChild(eempty);
      } else {
        ls.events.forEach(ev => {
          const evdiv = document.createElement('div');
          evdiv.className = 'event';
          const ts = ev.timestamp || '';
          const msg = ev.message || '';
          // show timestamp on top and message below for readability
          evdiv.innerHTML = `<div style="color:#0b3550; font-weight:600">${ts}</div><div style="margin-top:6px; white-space:pre-wrap">${escapeHtml(msg)}</div>`;
          div.appendChild(evdiv);
        });
      }

      container.appendChild(div);
    });

    // also show raw JSON toggle
    const raw = document.createElement('pre');
    raw.style.marginTop = '12px';
    raw.textContent = JSON.stringify(obj, null, 2);
    container.appendChild(raw);
  }

  // simple HTML escape
  function escapeHtml(s) {
    if (!s) return '';
    return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  document.getElementById('fetchBtn').addEventListener('click', fetchLogs);
  document.getElementById('clearBtn').addEventListener('click', clearResults);

  // optional: prefill API URL from query param when file opened like:
  // log-tester.html?api=https://...
  (function prefillFromQuery() {
    const qp = new URLSearchParams(window.location.search);
    const api = qp.get('api');
    if (api) document.getElementById('apiUrl').value = api;
  })();
</script>
</body>
</html>











import boto3
import json
from datetime import datetime, timezone
import os

logs = boto3.client('logs')

# Preconfigured log group (secure)
LOG_GROUP_NAME = os.environ.get("LOG_GROUP_NAME", "/aws/codebuild/github-runner-logs")

def lambda_handler(event, context):
    try:
        params = event.get("queryStringParameters") or {}

        # Extract user-provided filters
        run_id = params.get("run_id")
        repo_name = params.get("repo_name")
        job_name = params.get("job_name")
        from_time = params.get("from")
        to_time = params.get("to")

        # Convert timestamps to milliseconds
        start_time = None
        end_time = None
        if from_time:
            start_time = int(datetime.fromisoformat(from_time.replace('Z', '+00:00')).timestamp() * 1000)
        if to_time:
            end_time = int(datetime.fromisoformat(to_time.replace('Z', '+00:00')).timestamp() * 1000)

        # Build stream name filter
        filters = [f for f in [run_id, repo_name, job_name] if f]

        # Fetch matching log streams
        matching_streams = []
        paginator = logs.get_paginator("describe_log_streams")
        for page in paginator.paginate(logGroupName=LOG_GROUP_NAME):
            for stream in page.get("logStreams", []):
                name = stream["logStreamName"]
                if all(f in name for f in filters):
                    matching_streams.append(name)

        if not matching_streams:
            return {
                "statusCode": 200,
                "headers": {"Access-Control-Allow-Origin": "*"},
                "body": json.dumps({"logStreams": []})
            }

        # Fetch log events for each matching stream
        result = {"logStreams": []}
        for stream_name in matching_streams:
            kwargs = {
                "logGroupName": LOG_GROUP_NAME,
                "logStreamName": stream_name,
                "startFromHead": True
            }

            if start_time:
                kwargs["startTime"] = start_time
            if end_time:
                kwargs["endTime"] = end_time

            response = logs.get_log_events(**kwargs)
            events = [
                {
                    "timestamp": datetime.fromtimestamp(e["timestamp"] / 1000, tz=timezone.utc).isoformat(),
                    "message": e["message"]
                } for e in response.get("events", [])
            ]

            result["logStreams"].append({
                "name": stream_name,
                "events": events
            })

        return {
            "statusCode": 200,
            "headers": {
                "Access-Control-Allow-Origin": "*",
                "Content-Type": "application/json"
            },
            "body": json.dumps(result)
        }

    except Exception as e:
        print("Error:", str(e))
        return {
            "statusCode": 500,
            "headers": {"Access-Control-Allow-Origin": "*"},
            "body": json.dumps({"error": str(e)})
        }











import json
import boto3
import time

logs = boto3.client('logs')

def lambda_handler(event, context):
    try:
        params = event.get('queryStringParameters') or {}
        log_group = params.get('logGroupName')
        query = params.get('query', '')
        start_time = int(time.time()) - 3600  # Default: last 1 hour
        end_time = int(time.time())

        if 'start' in params:
            start_time = int(params['start'])
        if 'end' in params:
            end_time = int(params['end'])

        if not log_group:
            return {
                'statusCode': 400,
                'body': json.dumps({'error': 'Missing logGroupName'})
            }

        # Run Logs Insights query
        query_string = f'fields @timestamp, @message | sort @timestamp desc | filter @message like /{query}/'
        response = logs.start_query(
            logGroupName=log_group,
            startTime=start_time,
            endTime=end_time,
            queryString=query_string,
            limit=50
        )

        query_id = response['queryId']

        # Wait for results
        time.sleep(2)
        result = logs.get_query_results(queryId=query_id)

        # Format results
        logs_list = []
        for r in result['results']:
            entry = {f['field']: f['value'] for f in r if f['field'] in ['@timestamp', '@message']}
            logs_list.append(entry)

        return {
            'statusCode': 200,
            'headers': {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*'
            },
            'body': json.dumps(logs_list)
        }

    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'error': str(e)})
        }





{
  "Effect": "Allow",
  "Action": [
    "logs:StartQuery",
    "logs:GetQueryResults",
    "logs:DescribeLogGroups",
    "logs:DescribeLogStreams"
  ],
  "Resource": "*"
}


<!DOCTYPE html>
<html>
<head>
  <title>CloudWatch Log Viewer</title>
  <style>
    body { font-family: Arial; padding: 20px; background: #f9fafb; }
    input, select, button { padding: 8px; margin: 5px; }
    pre { background: #111; color: #0f0; padding: 10px; border-radius: 8px; }
  </style>
</head>
<body>
  <h2>CloudWatch Log Viewer</h2>
  <label>Log Group:</label>
  <input type="text" id="logGroup" placeholder="/aws/lambda/my-function">
  <label>Search:</label>
  <input type="text" id="query" placeholder="error or keyword">
  <button onclick="fetchLogs()">Fetch Logs</button>
  <div id="result"></div>

  <script>
    const apiUrl = "https://abc123.execute-api.us-east-1.amazonaws.com/logs";

    async function fetchLogs() {
      const logGroup = document.getElementById('logGroup').value;
      const query = document.getElementById('query').value;
      const url = `${apiUrl}?logGroupName=${encodeURIComponent(logGroup)}&query=${encodeURIComponent(query)}`;

      document.getElementById('result').innerHTML = '<p>Loading...</p>';

      try {
        const res = await fetch(url);
        const data = await res.json();
        if (data.error) throw new Error(data.error);
        const logsHtml = data.map(d => `<pre>[${d['@timestamp']}] ${d['@message']}</pre>`).join('');
        document.getElementById('result').innerHTML = logsHtml || '<p>No logs found.</p>';
      } catch (err) {
        document.getElementById('result').innerHTML = `<p style="color:red;">Error: ${err.message}</p>`;
      }
    }
  </script>
</body>
</html>
