function extract_run_id_from_log(tag, timestamp, record)
    print("=== RUN_ID EXTRACTION START ===")
    print("Tag: " .. tostring(tag))
    print("Timestamp: " .. tostring(timestamp))
    
    -- Debug: Show all available record fields
    print("Available record fields:")
    local field_count = 0
    for k, v in pairs(record) do
        field_count = field_count + 1
        local value_preview = tostring(v)
        if string.len(value_preview) > 200 then
            value_preview = string.sub(value_preview, 1, 200) .. "...[TRUNCATED]"
        end
        print("  Field[" .. field_count .. "]: '" .. tostring(k) .. "' = '" .. value_preview .. "'")
    end
    print("Total fields found: " .. field_count)
    
    -- Try different field names in case "message" is wrong
    local message = record["message"] or record["log"] or record["content"]
    local field_used = "none"
    
    if record["message"] then
        field_used = "message"
        message = record["message"]
    elseif record["log"] then
        field_used = "log"
        message = record["log"]
    elseif record["content"] then
        field_used = "content"
        message = record["content"]
    end
    
    print("Using field: " .. field_used)
    print("Message exists: " .. (message and "YES" or "NO"))
    
    local run_id = "unknown"
    
    if message then
        print("Message length: " .. string.len(message))
        print("Message content (first 500 chars): " .. string.sub(message, 1, 500))
        
        -- Check if message contains run_id at all
        local contains_run_id = string.find(message, "run_id")
        print("Message contains 'run_id': " .. (contains_run_id and "YES at position " .. contains_run_id or "NO"))
        
        if contains_run_id then
            -- Look for the run_id pattern in JSON format
            -- Handle multiline, spaces, and indentation
            local json_pattern = '%{[^}]*"k"%s*:%s*"run_id"[^}]*"v"%s*:%s*"([^"]+)"[^}]*%}'
            local simple_pattern = '"k"%s*:%s*"run_id"[^}]*"v"%s*:%s*"([^"]+)"'
            
            print("Trying JSON pattern: " .. json_pattern)
            
            -- Try to match the full JSON object first
            local extracted_id = message:match(json_pattern)
            print("JSON pattern result: " .. (extracted_id or "NO MATCH"))
            
            -- If that doesn't work, try simpler pattern
            if not extracted_id then
                print("Trying simple pattern: " .. simple_pattern)
                extracted_id = message:match(simple_pattern)
                print("Simple pattern result: " .. (extracted_id or "NO MATCH"))
            end
            
            -- If still not found, try line by line for multiline JSON
            if not extracted_id then
                print("Trying multiline processing...")
                local lines = {}
                local line_count = 0
                
                for line in message:gmatch("[^\r\n]+") do
                    line_count = line_count + 1
                    local trimmed_line = line:gsub("^%s+", ""):gsub("%s+$", "")
                    table.insert(lines, trimmed_line)
                    print("  Line[" .. line_count .. "]: '" .. trimmed_line .. "'")
                end
                
                print("Total lines processed: " .. line_count)
                
                local combined = table.concat(lines, "")
                print("Combined lines: " .. combined)
                
                extracted_id = combined:match('"k"%s*:%s*"run_id"[^}]*"v"%s*:%s*"([^"]+)"')
                print("Multiline pattern result: " .. (extracted_id or "NO MATCH"))
            end
            
            if extracted_id then
                run_id = extracted_id
                print("SUCCESS: Extracted run_id = '" .. run_id .. "'")
            else
                print("FAILED: Could not extract run_id with any pattern")
                
                -- Additional debug: show what patterns we're actually matching against
                print("Debug: Showing actual characters around 'run_id':")
                local start_pos = string.find(message, "run_id")
                if start_pos then
                    local context_start = math.max(1, start_pos - 50)
                    local context_end = math.min(string.len(message), start_pos + 100)
                    local context = string.sub(message, context_start, context_end)
                    print("Context around run_id: '" .. context .. "'")
                    
                    -- Show character codes for debugging invisible characters
                    print("Character codes around run_id:")
                    for i = start_pos - 10, start_pos + 20 do
                        if i > 0 and i <= string.len(message) then
                            local char = string.sub(message, i, i)
                            print("  pos[" .. i .. "]: '" .. char .. "' (code: " .. string.byte(char) .. ")")
                        end
                    end
                end
            end
        else
            print("Message does not contain 'run_id' - nothing to extract")
        end
    else
        print("ERROR: No message field found to process")
        print("This means the field name might be different or multiline parsing failed")
    end
    
    -- Set the run_id field for use in log stream name
    record["run_id"] = run_id
    print("Final run_id set to: '" .. run_id .. "'")
    print("=== RUN_ID EXTRACTION END ===")
    
    return 1, timestamp, record
end




function extract_run_id_from_log(tag, timestamp, record)
    local message = record["message"]
    local run_id = "unknown"
    
    if message then
        -- Look for the run_id pattern in JSON format
        -- Handle multiline, spaces, and indentation
        local json_pattern = '%{[^}]*"k"%s*:%s*"run_id"[^}]*"v"%s*:%s*"([^"]+)"[^}]*%}'
        local simple_pattern = '"k"%s*:%s*"run_id"[^}]*"v"%s*:%s*"([^"]+)"'
        
        -- Try to match the full JSON object first
        local extracted_id = message:match(json_pattern)
        
        -- If that doesn't work, try simpler pattern
        if not extracted_id then
            extracted_id = message:match(simple_pattern)
        end
        
        -- If still not found, try line by line for multiline JSON
        if not extracted_id then
            local lines = {}
            for line in message:gmatch("[^\r\n]+") do
                table.insert(lines, line:gsub("^%s+", ""):gsub("%s+$", ""))
            end
            
            local combined = table.concat(lines, "")
            extracted_id = combined:match('"k"%s*:%s*"run_id"[^}]*"v"%s*:%s*"([^"]+)"')
        end
        
        if extracted_id then
            run_id = extracted_id
        end
    end
    
    -- Set the run_id field for use in log stream name
    record["run_id"] = run_id
    return 1, timestamp, record
end




[PARSER]
    Name        github_worker
    Format      regex
    Regex       ^\[(?<time>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})z (?<level>\w+)(?<source>[^\]]*)\](?<message>.*)
    Time_Key    time
    Time_Format %Y-%m-%d %H:%M:%S
    Time_Keep   On

[MULTILINE_PARSER]
    name          github_worker_multiline
    type          regex
    flush_timeout 1000
    # Rule for start_state: matches lines beginning with [YYYY-MM-DD HH:MM:SSz LEVEL]
    rule          "start_state"   "^\[[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}z [A-Z]+\]"  "cont"
    # Rule for continuation: continue until we see another timestamp pattern
    rule          "cont"          "^(?!\[[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}z [A-Z]+\])"  "cont"

[MULTILINE_PARSER]
    name          github_worker_multiline
    type          regex
    flush_timeout 1000
    rule          "start_state"  "^\[\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}z \w+[^\]]*\]"  "cont"
    rule          "cont"         "^(?!\[\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}z \w+[^\]]*\])"  "cont"
