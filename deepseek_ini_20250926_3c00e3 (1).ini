-- Global state to track if we found "k": "run_id" on the previous line
if not expecting_run_id_value then
    expecting_run_id_value = false
end

-- Global state to store the found run_id for this file
if not file_run_id then
    file_run_id = "unknown"
    found_file_run_id = false
end

function extract_run_id_from_log(tag, timestamp, record)
    print("=== RUN_ID EXTRACTION ===")
    
    -- If we already found the run_id for this file, return it immediately
    if found_file_run_id then
        print("🎯 Using cached run_id for this file: '" .. file_run_id .. "'")
        record["run_id"] = file_run_id
        print("📤 Returning cached run_id: '" .. file_run_id .. "'")
        print("=== END EXTRACTION (CACHED) ===")
        return 1, timestamp, record
    end
    
    -- Get content from any available field and clean it up
    local content = record["log"] or record["message"] or ""
    local line = content:gsub("^%s+", ""):gsub("%s+$", ""):gsub(",$", "")  -- Remove leading/trailing spaces and trailing comma
    
    print("Raw content: '" .. content .. "'")
    print("Cleaned line: '" .. line .. "'")
    print("Expecting run_id value: " .. (expecting_run_id_value and "YES" or "NO"))
    print("Current file_run_id: '" .. file_run_id .. "'")
    
    if line and line ~= "" then
        if expecting_run_id_value then
            print("🔍 Looking for 'v' value on this line...")
            
            -- Extract the "v" value - handle various spacing patterns
            local patterns = {
                '"v"%s*:%s*"([^"]+)"',      -- "v": "value"
                '"v":%s*"([^"]+)"',         -- "v":"value" 
                '"v"%s*:%s*\'([^\']+)\'',   -- "v": 'value' (single quotes)
                '"v":%s*\'([^\']+)\''       -- "v":'value'
            }
            
            for i, pattern in ipairs(patterns) do
                local value = line:match(pattern)
                if value then
                    file_run_id = value              -- Store in file-level variable
                    found_file_run_id = true         -- Mark as found for this file
                    expecting_run_id_value = false
                    print("✅ SUCCESS: Found and cached run_id = '" .. file_run_id .. "' using pattern " .. i)
                    print("🛑 CACHED for entire file - will reuse for all remaining lines")
                    break
                end
            end
            
            if not found_file_run_id then
                print("❌ Expected 'v' value but pattern didn't match: " .. line)
                expecting_run_id_value = false  -- Reset to avoid getting stuck
            end
            
        else
            print("🔍 Checking if this line has 'k': 'run_id'...")
            
            -- Check if this line contains "k": "run_id" - handle various spacing
            local k_patterns = {
                '"k"%s*:%s*"run_id"',       -- "k": "run_id"
                '"k":%s*"run_id"',          -- "k":"run_id"
                '"k"%s*:%s*\'run_id\'',     -- "k": 'run_id' (single quotes)
                '"k":%s*\'run_id\''         -- "k":'run_id'
            }
            
            for i, pattern in ipairs(k_patterns) do
                if line:match(pattern) then
                    expecting_run_id_value = true
                    print("✅ Found 'k': 'run_id' using pattern " .. i .. ", expecting value on next line")
                    break
                end
            end
            
            if not expecting_run_id_value then
                print("ℹ️  Line doesn't contain 'k': 'run_id'")
            end
        end
    else
        print("ℹ️  Empty line, maintaining current state")
    end
    
    -- Set the run_id field for CloudWatch log stream name
    record["run_id"] = file_run_id
    
    print("📤 Final run_id: '" .. file_run_id .. "'")
    print("📋 State for next line - expecting_run_id_value: " .. (expecting_run_id_value and "YES" or "NO"))
    print("📋 File run_id found: " .. (found_file_run_id and "YES" or "NO"))
    print("=== END EXTRACTION ===")
    
    return 1, timestamp, record
end











-- File-scoped variables (reset per file automatically)
if not file_state then
    file_state = {
        run_id = "unknown",
        found = false,
        waiting_for_v = false
    }
end

function extract_run_id_from_log(tag, timestamp, record)
    -- Quick return if already found
    if file_state.found then
        record["run_id"] = file_state.run_id
        return 1, timestamp, record
    end
    
    local line = (record["log"] or record["message"] or ""):gsub("^%s+", ""):gsub("%s+$", ""):gsub(",$", "")
    
    if file_state.waiting_for_v then
        local value = line:match('"v"%s*:%s*"([^"]+)"')
        if value then
            file_state.run_id = value
            file_state.found = true
            print("✅ Found run_id for file: " .. value)
        end
        file_state.waiting_for_v = false
        
    elseif line:find('"k"') and line:find('run_id') then
        file_state.waiting_for_v = true
    end
    
    record["run_id"] = file_state.run_id
    return 1, timestamp, record
end









-- Global state to track if we found "k": "run_id" on the previous line
if not expecting_run_id_value then
    expecting_run_id_value = false
end

function extract_run_id_from_log(tag, timestamp, record)
    print("=== RUN_ID EXTRACTION ===")
    
    -- Get content from any available field and clean it up
    local content = record["log"] or record["message"] or ""
    local line = content:gsub("^%s+", ""):gsub("%s+$", ""):gsub(",$", "")  -- Remove leading/trailing spaces and trailing comma
    
    local run_id = "unknown"
    
    print("Raw content: '" .. content .. "'")
    print("Cleaned line: '" .. line .. "'")
    print("Expecting run_id value: " .. (expecting_run_id_value and "YES" or "NO"))
    
    if line and line ~= "" then
        if expecting_run_id_value then
            print("🔍 Looking for 'v' value on this line...")
            
            -- Extract the "v" value - handle various spacing patterns
            local patterns = {
                '"v"%s*:%s*"([^"]+)"',      -- "v": "value"
                '"v":%s*"([^"]+)"',         -- "v":"value" 
                '"v"%s*:%s*\'([^\']+)\'',   -- "v": 'value' (single quotes)
                '"v":%s*\'([^\']+)\''       -- "v":'value'
            }
            
            for i, pattern in ipairs(patterns) do
                local value = line:match(pattern)
                if value then
                    run_id = value
                    print("✅ SUCCESS: Found run_id = '" .. run_id .. "' using pattern " .. i)
                    expecting_run_id_value = false
                    break
                end
            end
            
            if run_id == "unknown" then
                print("❌ Expected 'v' value but pattern didn't match: " .. line)
                expecting_run_id_value = false  -- Reset to avoid getting stuck
            end
            
        else
            print("🔍 Checking if this line has 'k': 'run_id'...")
            
            -- Check if this line contains "k": "run_id" - handle various spacing
            local k_patterns = {
                '"k"%s*:%s*"run_id"',       -- "k": "run_id"
                '"k":%s*"run_id"',          -- "k":"run_id"
                '"k"%s*:%s*\'run_id\'',     -- "k": 'run_id' (single quotes)
                '"k":%s*\'run_id\''         -- "k":'run_id'
            }
            
            for i, pattern in ipairs(k_patterns) do
                if line:match(pattern) then
                    expecting_run_id_value = true
                    print("✅ Found 'k': 'run_id' using pattern " .. i .. ", expecting value on next line")
                    break
                end
            end
            
            if not expecting_run_id_value then
                print("ℹ️  Line doesn't contain 'k': 'run_id'")
            end
        end
    else
        print("ℹ️  Empty line, maintaining current state")
    end
    
    -- Set the run_id field for CloudWatch log stream name
    record["run_id"] = run_id
    
    print("📤 Final run_id: '" .. run_id .. "'")
    print("📋 State for next line - expecting_run_id_value: " .. (expecting_run_id_value and "YES" or "NO"))
    print("=== END EXTRACTION ===")
    
    return 1, timestamp, record
end



function extract_run_id_from_log(tag, timestamp, record)
    print("=== RUN_ID EXTRACTION START ===")
    print("Tag: " .. tostring(tag))
    print("Timestamp: " .. tostring(timestamp))
    
    -- Debug: Show all available record fields
    print("Available record fields:")
    local field_count = 0
    for k, v in pairs(record) do
        field_count = field_count + 1
        local value_preview = tostring(v)
        if string.len(value_preview) > 200 then
            value_preview = string.sub(value_preview, 1, 200) .. "...[TRUNCATED]"
        end
        print("  Field[" .. field_count .. "]: '" .. tostring(k) .. "' = '" .. value_preview .. "'")
    end
    print("Total fields found: " .. field_count)
    
    -- Try different field names in case "message" is wrong
    local message = record["message"] or record["log"] or record["content"]
    local field_used = "none"
    
    if record["message"] then
        field_used = "message"
        message = record["message"]
    elseif record["log"] then
        field_used = "log"
        message = record["log"]
    elseif record["content"] then
        field_used = "content"
        message = record["content"]
    end
    
    print("Using field: " .. field_used)
    print("Message exists: " .. (message and "YES" or "NO"))
    
    local run_id = "unknown"
    
    if message then
        print("Message length: " .. string.len(message))
        print("Message content (first 500 chars): " .. string.sub(message, 1, 500))
        
        -- Check if message contains run_id at all
        local contains_run_id = string.find(message, "run_id")
        print("Message contains 'run_id': " .. (contains_run_id and "YES at position " .. contains_run_id or "NO"))
        
        if contains_run_id then
            -- Look for the run_id pattern in JSON format
            -- Handle multiline, spaces, and indentation
            local json_pattern = '%{[^}]*"k"%s*:%s*"run_id"[^}]*"v"%s*:%s*"([^"]+)"[^}]*%}'
            local simple_pattern = '"k"%s*:%s*"run_id"[^}]*"v"%s*:%s*"([^"]+)"'
            
            print("Trying JSON pattern: " .. json_pattern)
            
            -- Try to match the full JSON object first
            local extracted_id = message:match(json_pattern)
            print("JSON pattern result: " .. (extracted_id or "NO MATCH"))
            
            -- If that doesn't work, try simpler pattern
            if not extracted_id then
                print("Trying simple pattern: " .. simple_pattern)
                extracted_id = message:match(simple_pattern)
                print("Simple pattern result: " .. (extracted_id or "NO MATCH"))
            end
            
            -- If still not found, try line by line for multiline JSON
            if not extracted_id then
                print("Trying multiline processing...")
                local lines = {}
                local line_count = 0
                
                for line in message:gmatch("[^\r\n]+") do
                    line_count = line_count + 1
                    local trimmed_line = line:gsub("^%s+", ""):gsub("%s+$", "")
                    table.insert(lines, trimmed_line)
                    print("  Line[" .. line_count .. "]: '" .. trimmed_line .. "'")
                end
                
                print("Total lines processed: " .. line_count)
                
                local combined = table.concat(lines, "")
                print("Combined lines: " .. combined)
                
                extracted_id = combined:match('"k"%s*:%s*"run_id"[^}]*"v"%s*:%s*"([^"]+)"')
                print("Multiline pattern result: " .. (extracted_id or "NO MATCH"))
            end
            
            if extracted_id then
                run_id = extracted_id
                print("SUCCESS: Extracted run_id = '" .. run_id .. "'")
            else
                print("FAILED: Could not extract run_id with any pattern")
                
                -- Additional debug: show what patterns we're actually matching against
                print("Debug: Showing actual characters around 'run_id':")
                local start_pos = string.find(message, "run_id")
                if start_pos then
                    local context_start = math.max(1, start_pos - 50)
                    local context_end = math.min(string.len(message), start_pos + 100)
                    local context = string.sub(message, context_start, context_end)
                    print("Context around run_id: '" .. context .. "'")
                    
                    -- Show character codes for debugging invisible characters
                    print("Character codes around run_id:")
                    for i = start_pos - 10, start_pos + 20 do
                        if i > 0 and i <= string.len(message) then
                            local char = string.sub(message, i, i)
                            print("  pos[" .. i .. "]: '" .. char .. "' (code: " .. string.byte(char) .. ")")
                        end
                    end
                end
            end
        else
            print("Message does not contain 'run_id' - nothing to extract")
        end
    else
        print("ERROR: No message field found to process")
        print("This means the field name might be different or multiline parsing failed")
    end
    
    -- Set the run_id field for use in log stream name
    record["run_id"] = run_id
    print("Final run_id set to: '" .. run_id .. "'")
    print("=== RUN_ID EXTRACTION END ===")
    
    return 1, timestamp, record
end




function extract_run_id_from_log(tag, timestamp, record)
    local message = record["message"]
    local run_id = "unknown"
    
    if message then
        -- Look for the run_id pattern in JSON format
        -- Handle multiline, spaces, and indentation
        local json_pattern = '%{[^}]*"k"%s*:%s*"run_id"[^}]*"v"%s*:%s*"([^"]+)"[^}]*%}'
        local simple_pattern = '"k"%s*:%s*"run_id"[^}]*"v"%s*:%s*"([^"]+)"'
        
        -- Try to match the full JSON object first
        local extracted_id = message:match(json_pattern)
        
        -- If that doesn't work, try simpler pattern
        if not extracted_id then
            extracted_id = message:match(simple_pattern)
        end
        
        -- If still not found, try line by line for multiline JSON
        if not extracted_id then
            local lines = {}
            for line in message:gmatch("[^\r\n]+") do
                table.insert(lines, line:gsub("^%s+", ""):gsub("%s+$", ""))
            end
            
            local combined = table.concat(lines, "")
            extracted_id = combined:match('"k"%s*:%s*"run_id"[^}]*"v"%s*:%s*"([^"]+)"')
        end
        
        if extracted_id then
            run_id = extracted_id
        end
    end
    
    -- Set the run_id field for use in log stream name
    record["run_id"] = run_id
    return 1, timestamp, record
end




[PARSER]
    Name        github_worker
    Format      regex
    Regex       ^\[(?<time>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})z (?<level>\w+)(?<source>[^\]]*)\](?<message>.*)
    Time_Key    time
    Time_Format %Y-%m-%d %H:%M:%S
    Time_Keep   On

[MULTILINE_PARSER]
    name          github_worker_multiline
    type          regex
    flush_timeout 1000
    # Rule for start_state: matches lines beginning with [YYYY-MM-DD HH:MM:SSz LEVEL]
    rule          "start_state"   "^\[[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}z [A-Z]+\]"  "cont"
    # Rule for continuation: continue until we see another timestamp pattern
    rule          "cont"          "^(?!\[[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}z [A-Z]+\])"  "cont"

[MULTILINE_PARSER]
    name          github_worker_multiline
    type          regex
    flush_timeout 1000
    rule          "start_state"  "^\[\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}z \w+[^\]]*\]"  "cont"
    rule          "cont"         "^(?!\[\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}z \w+[^\]]*\])"  "cont"
